Sistema de Gerenciamento de Entregas (Log√≠stica)API REST desenvolvida para o gerenciamento de pedidos log√≠sticos, focada em resili√™ncia, baixa lat√™ncia e consist√™ncia de dados utilizando uma arquitetura orientada a eventos.üöÄ Como Executar o ProjetoO projeto foi desenhado para ser agn√≥stico ao ambiente de desenvolvimento, podendo ser executado inteiramente via Docker.Pr√©-requisitosDocker e Docker Compose instalados.(Opcional) Java 17 e Maven para execu√ß√£o local (fora do Docker).Op√ß√£o 1: Execu√ß√£o Completa via Docker (Recomendado)Este comando sobe o Banco de Dados, o RabbitMQ e a Aplica√ß√£o Java automaticamente. Ideal para testar sem instalar o Java na m√°quina.docker-compose up --build
API: http://localhost:8080/api/ordersRabbitMQ Management: http://localhost:15672 (Login: guest / guest)Op√ß√£o 2: Execu√ß√£o em Desenvolvimento (Local)Para desenvolvedores que desejam rodar a aplica√ß√£o na IDE (IntelliJ/Eclipse) para debug.Suba a infraestrutura de apoio (Banco e Fila):docker-compose up postgres rabbitmq -d
Execute a aplica√ß√£o via Maven:mvn spring-boot:run
üèóÔ∏è Arquitetura e DesignO sistema segue uma arquitetura de Microsservi√ßo Orientado a Eventos.graph LR
    User[Cliente] -- POST /orders --> API[Order API]
    API -- 1. Salva (Transacional) --> DB[(PostgreSQL)]
    API -- 2. Envia (Best Effort) --> Rabbit{RabbitMQ}
    Rabbit -- 3. Consome --> Worker[Consumer]
    Worker -- 4. Atualiza Status --> DB
    Job[Job de Recupera√ß√£o] -- 5. Reenvia Falhas --> Rabbit
Fluxo de DadosRecebimento: A API recebe o pedido.Persist√™ncia At√¥mica: O pedido (orders) e o evento de cria√ß√£o (order_events) s√£o salvos na mesma transa√ß√£o de banco de dados, garantindo que o hist√≥rico nunca seja perdido.Propaga√ß√£o: O sistema tenta enviar o evento para o RabbitMQ imediatamente.Processamento Ass√≠ncrono: Um consumidor (Worker) l√™ a fila, simula o tempo de transporte log√≠stico e atualiza o status do pedido at√© a entrega final (DELIVERED).üß† Estrat√©gias AdotadasPara atender aos requisitos t√©cnicos rigorosos, foram adotadas as seguintes estrat√©gias:1. Garantia de Consist√™ncia Total (Transactional Outbox Simplificado)Para resolver o problema de Dual Write (escrever no banco e na fila simultaneamente sem perder dados), utilizei a tabela order_events como controle.Estrat√©gia: Todo evento √© persistido com o status sent = false dentro da transa√ß√£o do pedido.Resultado: Se a aplica√ß√£o cair logo ap√≥s salvar no banco, o evento continua l√°, seguro.2. Resili√™ncia e Auto-Recupera√ß√£o (Self-Healing)O sistema √© capaz de se recuperar de falhas no Broker de mensagens sem interven√ß√£o humana.Mecanismo: Um Job Agendado (EventPublisherJob) roda a cada 10 segundos. Ele busca no banco eventos que ainda n√£o foram enviados (sent = false) e tenta reenvi√°-los.Cen√°rio de Falha: Se o RabbitMQ cair, a API continua aceitando pedidos (Status 201), mas os eventos ficam pendentes. Assim que o RabbitMQ voltar, o Job processa o acumulado automaticamente.3. Baixa Lat√™ncia (Best Effort Delivery)Para n√£o penalizar o usu√°rio esperando o Job rodar:A aplica√ß√£o tenta enviar a mensagem para a fila imediatamente ap√≥s o commit no banco.Se o RabbitMQ estiver online, o evento √© processado em milissegundos. O Job atua apenas como "rede de seguran√ßa" (fallback).üõ†Ô∏è Tecnologias UtilizadasTecnologiaJustificativaJava 17 + Spring Boot 3Plataforma robusta, moderna e com excelente ecossistema para microsservi√ßos e integra√ß√£o com mensageria (Spring AMQP).PostgreSQLBanco relacional ACID para garantir a integridade dos dados cr√≠ticos (Pedidos) e Hist√≥rico.RabbitMQBroker de mensagens maduro e amplamente utilizado para desacoplar a recep√ß√£o do pedido do processamento log√≠stico.Docker & Docker ComposeGarante que a aplica√ß√£o rode da mesma forma na m√°quina do desenvolvedor e no servidor, facilitando a avalia√ß√£o ("Plug and Play").TestcontainersUtilizado nos testes de integra√ß√£o para subir containers reais do banco e fila, garantindo que o teste valide o ambiente real e n√£o apenas mocks.LombokRedu√ß√£o de c√≥digo repetitivo (boilerplate), focando na regra de neg√≥cio.üß™ Testes AutomatizadosO projeto possui uma su√≠te de testes de integra√ß√£o (OrderApiIntegrationTest) que valida o fluxo ponta a ponta:Cria√ß√£o via API.Persist√™ncia no Banco.Envio/Recebimento na Fila.Atualiza√ß√£o de Status pelo Worker.Para rodar os testes:mvn test
üîó Endpoints PrincipaisM√©todoRotaDescri√ß√£oPOST/api/ordersCria um novo pedido. Body: { "customerId": "string" }GET/api/orders/{id}Consulta o status atual do pedido.GET/api/orders/{id}/eventsConsulta o hist√≥rico de eventos (Auditoria).